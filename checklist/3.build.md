# Build
- 開発時のコードレベルのチェックリスト


# IPO
- I（インプット）：前提条件・事前準備
- P（プロセス）：進め方・観点
  - ビルドドリブンだと、アンダーエンジニアリングになりがち
- O（アウトプット）
  - 構築環境
    - フォーマッター定義
    - フレームワーク：利用バージョンの設定値確認、プラクティス用意
    - フレームワーク：EOL確認（Postgres/Java等）
    - 共通定義（定数）
    - サンプル実装
  - ガイド
    - コーディングガイド
      - プラクティス
      - コミットコメント
      - コメントルール
      - ブランチ戦略
    - UTガイド
      - 命名規則
    - レビューガイド
    - コーディング完了クライテリア
      - FE
        - 画面エビデンス
          - 初期値
          - エンプティ
          - 最大文字
          - 全ての状態パターンの見た目
          - 入力チェックエラー（相関チェックエラー）
          - 無限スクロール
      - BE
        - カバレッジ
        - Lintエラーなし
        - ログ出力
          - すぐ参照可能か（同じログ出力してないか、例外に必ずログ出力含めているか/結局どこで例外か不明）
          - エラーログ
    - Wording一覧
    - 計測
      - スタップ数
      - 品質
        - テスト密度
        - テスト効率
        - バグ密度
    - 手順書
      - デプロイ

#### オフショア（品質管理はオン責任、スケジュール管理はオフ責任）　
    オフショア開発は実装ドリブントラップに陥りやすく、アンダーエンジニアリングになりがちである
    さらにリモートのため、仕様齟齬が発生しやすく容易に情報同期できない点を意識して、必要な仕組みづくりを適宜行っていくことが重要である。
    （設計書管理も品質が低下したり陳腐化しがちのため、オンショア管理が必要）
    また、パフォーマンス維持の施策として、定期の人材の評価とローテーションが必要
オフショア開発前提（品質管理必要）
- デザインを見て、デザイン通りに作れない（フォント、色、サイズ等）
- 技術課題解消できない
- バグ再現できない
- エラー処理認識してない（開発漏れ）
- 横展開しない
- 翻訳ミスでQA多発する
- 遅延する（そしてオンサイトの責任にする/Done is better than perfect）

#### 準備項目（オフショアに提供するもの）
    内部品質（テスト容易性/理解容易性/変更容易性）は、コードの提供やルールの展開によって仕組みづくりを十分に行うことで、開発速度を犠牲にせず、高めていくことが必要。
    設計変更は常に起こるため、安全についていくために重要。

エクセルの一覧や定義を参照させるより、横断的なコンポーネント、設定はオン側で提供する。（余計なバグリスクを減らす）
- デザイン定義
  - 色
  - フォント
- 文言（汎用文言）
  - エンプティメッセージ
  - デフォルトメッセージ
  - エラーメッセージ
- 環境定義
  - エンドポイント定義
  - 向き先定義（test1/test2/stage）
- FEサンプル
  - 認証連携（ログイン）
  - エラーハンドリング
  - ページング
  - 無限スクロール
  - ２重クリック防止処理
  - フォーム（input/testarea）エラーバリデーションも含め
    - ボタン
    - インプット
    - プルダウン
    - インラインエラー
    - ローディング
    - Unit Test（エビデンスサンプル）
    - 汎用コードクラス（ENUM）
  - BEサンプル
    - ログ
    - 例外出力
    - Unit Test
    - 共通処理
      - 日付計算
      - 金額計算
    - キャッシュ・セッション・Cookie
    - 暗号化：暗号化・ハッシュ（パスワードハッシュ）・HMAC
  - その他（設計）
    - レイアウト（ボタン、フォーム）：ステートパターン使えそうなところを整理（nice to have）
    -　デザインパターン （ステートパターンなど有限オートマトン：下書き→承認→公開）

## APIセキュリティチェックリスト
https://github.com/shieldfy/API-Security-Checklist/blob/master/README-ja.md

##　コーディングガイド
- コーディング
    - Wording（目的ベースで決定）名前はヘボン式のローマ字NG。（ただし、医療系(臓器、病名)などはヘボン式でもよい）
        - ネーミングは利用規約を見ると、厳密なワードが探しやすい
        - 住所→配送元・配送先・勤務先・本籍地
        - 金額→請求金額、消費税額、割引料金、
        - ユーザー名→アカウント名、表示名、本名、法人名
        - 商品→入庫品、予約品、注文品、発送品
    - SQL
        - 統一：大文字・小文字（inner join）
        - 統一：省略OK・NG（left join）
        - バルクインサートはCOPY推奨
- 言語ごとのコーディングガイド：https://github.com/NARKOZ/guides
- スタイルガイドの種類
    - 危険を避けるためのルール
    - ベストプラクティスを強制するルール
    - 一貫性を保証するためのルール

## ユニットテスト
    - 保守性の重要さ：脆いテストだと修正に時間ばかり取られる
    - 理想のテストとは変化しないテスト：変更は４種類ある
        - リファクタリング：テストがあれば安心してテストできる
        - 新機能：新機能を確認するため、既存テストを変更するのは、既存テストが不適切
        - バグ修正：バグ修正はテストが抜けていることが原因。テストの追加必要
        - 仕様変更：既存のテスト修正が必要
    - メソッドではなく、挙動をテストせよ：前提条件「〜のとき」操作「〜した場合」結果「〜となる」の３つの要素でテストは表現される
      - {API名}/validation・register/fail
    - テストにちなんで、テスト名を決める

## レビュー観点
- 構造品質（機械的にチェック可能。０件指摘が好ましい）
    - 静的チェッククリアしているか（Lint結果）
    - UT結果が十分か（網羅性、確認ポイント）
    - 少ないコードを書く（DRY：２重定義）：コピペを許さない
    - 取り除くことでコードを改善する（YAGNI）：デッドコードエリミネーションや将来必要となるコードを書かない
    - 異常系：例外の握りつぶしがないか（★）
- 機能品質（）
    - 設計通りか、バグがないか
    - メンテナンスが簡単か（負債となるか）
    - スレッドセーフか（スレッドセーフな型を使っているか）
    - 専門知識が必要か（必要なコメントあるか）
    - Smellfulなコードは質問する
    - ログ
        - ログ出力がわかりやすいか（エラー原因が特定しやすい、操作が特定しやすい）
        - トランザクション、セッションがわかるようにする。
        - ログレベルを定義する。
        - ログフォーマットを定義する
    - コメント
        - コメントはWHY（設計判断・仕様）を必ず記載。HOW（アルゴリズムやWEB標準、）はnice to have
    - 個別観点（リファクタリングも同じ→木こりのジレンマ：効率の悪い仕事の例え話）
        - 共通：重複はさせない、計算関数など
        - 共通：初期化ロジックを分散させない
        - 共通：コンストラクタをprivateにして、staticにする
        - 共通：目的別にファクトリーメソッド利用できるか検討する
        - 共通：共通関数にドメインの共通計算処理をおかない、IsMember(), calcTax(), placeOrder()
        - 共通：横断関心ごとを実装する
        - 引数：多すぎる引数（パラメータ）問題はクラス化で解決できるかも
        - 条件分岐：早期リターン、ガード節同じ条件をいろんなところに実装しない、switch 、ストラテジーパターン
        - コレクション：自前で書かない、anyMatch、allMatch、noneMatch
        - フラグ引数NG：フラグ引数をつかって、二倍コーディングするより、メソッドをわける、メソッドは単機能にする。
        - 引数にNULL渡さないよう設計（★）
        - 巨大メソッド（神クラス！！！）→処理ごとに分割
        - 単純に保つ（KISS）：複雑なコードを書かない
        - 時代遅れの実装（OLD Fashion）：for 文など

##　コーディングレビューポリシー
- 礼儀正しく：アプローチが間違っている場合でも、まず何故そのアプローチか質問するのが良い。
- 迅速にフィードバックを行う
- 何度もフィードバックを受けること避ける
- レビュー対象は機能ごとではなく、細かく分けることができる（大きすぎるのは拒絶できる）
- ボーイスカウトルールに準ずる（ボーイスカウトは賛辞の対象）
- 網の目を細かくする：複数のバグを一度に見つける（★★★）
- リーダブルコード
  - 理解しやすいコード：他の人が短時間で理解できるコード
  - 名前に情報を詰め込む：「カラフルな」単語を使う（汎用単語を避け、単位も含める）
  - 無関係の下位の問題を抽出する：下位の問題は抽出する。汎用関数はたくさん作る
- 割れた窓を放置しない
- 完璧とは何にも追加するものがないときではなく、何も取り去るべきもの無くなった時達成（サンテグジュベリ：フランスの作家）
- セルフレビューで構造品質はクリアしておくこと

    - SonarLint:（VSCode）

□Code Review Policy
- [must] 必ず対応が必要
- [imo] 自分の意見や提案・好み。 自分ならこう書くなど
- [nits] 些細な指摘。 インデントやタイポ
- [ask] 質問,確認。 コードの意味や背景など?
- [like]良いコード
- [memo]XXX

□REF
- コード・レビューでの5つのアンチパターン：https://blogs.oracle.com/otnjp/post/five-code-review-antipatterns-ja
- google：
  - https://developers-jp.googleblog.com/2019/12/respectful-reviews.html
  - https://google.github.io/eng-practices/review/reviewer/standard.html
  - https://research.google/pubs/modern-code-review-a-case-study-at-google/
- gitlab
  - https://docs.gitlab.com/ee/development/code_review.html
  - https://handbook.gitlab.com/handbook/engineering/workflow/reviewer-values/
- atlassian
  - https://www.atlassian.com/blog/add-ons/code-review-best-practices

- microsoft
  - https://devblogs.microsoft.com/appcenter/how-the-visual-studio-mobile-center-team-does-code-review/
  - https://learn.microsoft.com/en-us/shows/visual-studio-toolbox/improve-code-quality-with-code-reviews
- Auth0
  - https://auth0.com/blog/conducting-effective-code-reviews/
- netlify
  - https://www.netlify.com/blog/2020/03/05/feedback-ladders-how-we-encode-code-reviews-at-netlify/
- netflix
  - https://netflixtechblog.medium.com/improving-pull-request-confidence-for-the-netflix-tv-app-b85edb05eb65

■Design Patterns（23）
□Creational Design Patterns（5）
- Factory Method：インスタンス作成をサブクラスにまかせる（同じ抽象**メソッド**提供。トラック・船→Deliver）
- Abstract Factory：関連する部品を組み合わせて製品を作る（同じ抽象**メソッド群**提供。印象派・大正ロマン→draw、photo）
- Builder（★）：複雑なインスタンスを組み立てる
    - 検討の余地：コンストラクタが多くて読みにくい
    - 検討の余地：settter（生成を完了するまでのコードが長い）
- Prototype：コピーしてインスタンスを作る
- Singleton：たった１つのインスタンス

□Structural Design Patterns（7）
- Adapter（★）：一皮かぶせて再利用：（XML、JSON）
- Bridge：機能階層と実装の階層を分ける
- Composite：容器と中身の同一視（中身の種類が増えても追加・削除容易）
- Decorator（★）：飾り枠と中身の同一視
- Facade：シンプルな窓口
- Flyweight：同じものを共有して無駄をなくす
- Proxy：必要になってから作る（代理実行）

□Behavioral Design Patterns(10)
- Chain of Responsibility：責任のたらい回し（連鎖実行）
- Command：命令をクラスにする
- Iterator：１つ１つ数え上げる（collectionと順番を独立させる）→旅行移動手段（walk, phone-guide、man-guide）
- Mediator：相手は相談役一人だけ
- Memento：状態を保存する（スナップショット）
- Observer：状態の変化を通知する
- State（★）：状態をクラスとして表現する：（有限オートマトン：下書き→承認→公開）
- Strategy：アルゴリズムをごっそり切り替える（★ラムダ式利用推奨）
- Template Method：具体的な処理をサブクラスにまかせる
- Visitor：構造を渡り歩きながら仕事をする
